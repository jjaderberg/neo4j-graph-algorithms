= Community detection: Strongly Connected Components

_SCC_ is a class algorithms for finding groups of nodes where each node is directly reachable from every other node in the group. 
The strongly connected components  of an arbitrary directed graph form a partition into subgraphs that are themselves strongly connected.There are several algorithms to compute the SCC.

== History, Explanation

Decomposing a directed graph into its strongly connected components is a classic application of depth-first search. 
The problem of finding connected components is at the heart of many graph application. 
Generally speaking, the connected components of the graph correspond to different classes of objects. 
The first linear-time algorithm for strongly connected components is due to Tarjan (1972).

== When to use it / use-cases

_SCC_ algorithms can be used as a first step in many graph algorithms that work only on strongly connected graph.
In social networks, a group of people are generally strongly connected (For example, students of a class or any other common place). 
Many people in these groups generally like some common pages or play common games. 
The SCC algorithms can be used to find such groups and suggest the commonly liked pages or games to the people in the group who have not yet liked commonly liked a page or played a game.

== Constraints / when not to use it

== Algorithm explanation on simple sample graph

image::strongly_connected_components.png[]

A directed graph is strongly connected if there is a path between all pairs of vertices. 
This algorithms treats the graph as directed, so the direction of the relationship is important and strongly connected compoment exists only if there are relationships between nodes in both direction. 

.Create sample graph
[source,cypher]
----
include::scripts/strongly-connected-components.cypher[tag=create-sample-graph]

----

.Running algorithm and writing back results
[source,cypher]
----
include::scripts/strongly-connected-components.cypher[tag=write-sample-graph]

----

.Results
[opts="header",cols="1,1"]
|===
| name | partition
| Alice | 1
| Bridget | 1
| Michael | 1
| Charles | 0
| Doug | 2
| Mark | 2 
|===

We can see that we have 2 strongly connected components in our sample graph. The first and biggest component has members Alice,Bridget,Michael and the second component has Doug and Mark. 

.Find the largest partition
[source,cypher]
----
include::scripts/strongly-connected-components.cypher[tag=get-largest-component]
----
== Example Usage

== Syntax

.Running algorithm and writing back results
[source,cypher]
----
CALL algo.scc(label:String, relationship:String, 
{write:true,partitionProperty:'partition',concurrency:4, graph:'heavy'}) 
YIELD loadMillis, computeMillis, writeMillis, setCount, maxSetSize, minSetSize

- finds strongly connected partitions and potentially writes back to the node as a property partition. 
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| name | type | default | optional | description
| label  | string | null | yes | label to load from the graph, if null load all nodes
| relationship | string | null | yes | relationship-type to load from the graph, if null load all nodes
| write | boolean | true | yes | if result should be written back as node property
| partitionProperty | string | 'partition' | yes | property name written back to
| concurrency | int | available CPUs | yes | number of concurrent threads
| graph | string | 'heavy' | yes | use 'heavy' when describing the subset of the graph with label and relationship-type parameter, 'cypher' for describing the subset with cypher node-statement and relationship-statement

|===

.Results
[opts="header",cols="1,1,6"]
|===
| name | type | description
| setCount | int | number of partitions found
| maxSetSize | int | number of members in biggest partition
| minSetSize | int | number of members in smallest partition
| loadMillis | int | milliseconds for loading data
| computeMillis | int | milliseconds for running the algorithm
| writeMillis | int | milliseconds for writing result data back
|===
== Cypher loading

If label and relationship-type are not selective enough to describe your subgraph to run the algorithm on, you can use Cypher statements to load or project subsets of your graph.
Can be also used to run algorithms on a virtual graph.
Set `graph:'cypher'` in the config.

[source,cypher]
----
include::scripts/strongly-connected-components.cypher[tag=cypher-loading]
----
== Implementations

`algo.scc`

- *iterative* adaptation (same as `algo.scc.iterative`)

`algo.scc.recursive.tarjan`

- original *recursive* tarjan implementation

`algo.scc.recursive.tunedTarjan`

- also a *recursive* tarjan implementation

`algo.scc.iterative` 

- *iterative* adaption of tarjan algorithm

`algo.scc.multistep`

- parallel scc algorithm

== References

* https://pdfs.semanticscholar.org/61db/6892a92d1d5bdc83e52cc18041613cf895fa.pdf

* http://code.activestate.com/recipes/578507-strongly-connected-components-of-a-directed-graph/

* http://www.sandia.gov/~srajama/publications/BFS_and_Coloring.pdf



ifdef::implementation[]
// tag::implementation[]

== Implementation Details

:leveloffset: +1
// copied from: https://github.com/neo4j-contrib/neo4j-graph-algorithms/issues/97

_SCC_ is a class algorithms for finding groups of nodes where each node is directly reachable from every other node in the group. There are several algorithms to compute the SCC. Our current implementation (still in graphtest project) implements _Tarjan's_ SCC algorithm.

## Progress

- [x] implement procedure
- [x] tests
- [x] edge case tests
- [x] simple benchmark 
- [x] benchmark on bigger graphs
- [x] parallelization
- [x] evaluation
- [x] documentation

== Details

=== algo.scc.tarjan

- original *recursive* tarjan implementation
- result is a cluster-id at all nodes
- each cluster is a scc
- Builds sets of node-Ids which represent a strongly connected component
 within the graph. Also calculates minimum and maximum setSize as well
 as the count of distinct sets.

=== algo.scc.tunedTarjan

- also a recursive tarjan implementation
- result is a cluster-id at all nodes
- https://pdfs.semanticscholar.org/61db/6892a92d1d5bdc83e52cc18041613cf895fa.pdf

=== algo.scc.iterative

- *iterative* adaption of tarjan algorithm
- result is a cluster-id at all nodes
- http://code.activestate.com/recipes/578507-strongly-connected-components-of-a-directed-graph/

=== algo.scc.multistep

- parallel scc algorithm
- composition of several scc algorithms (FWBW, coloring, tarjan)
- uses FWBW + coloring to find big scc's
- starts simple tarjan once the cutoff threshold is reached
- http://www.sandia.gov/~srajama/publications/BFS_and_Coloring.pdf


// end::implementation[]
endif::implementation[]
